# 부르트 포스(Brute-force)
    모든 경우의 수를 탐색하여 문제를 해결하는 방식

- '무식하게 밀어붙인다' 라는 뜻
- 가장 단순한 풀이 기법, 단순 조건문과 반복문으로 이용 가능
- 아이디어를 어떻게 코드로 구현할 것인지가 중요

# 델타 탐색(Delta Search)
    이차원 리스트의 모든 원소를 순회하며 각 지점에서 상하좌우에 위치한 다른 지점을 조회하거나 이동하는 방식
- 행과 열의 변량인 -1, +1을 **델타(delta)값**이라 한다.

```python
# 델타값을 이용해 상하좌우로 이동하기

# 1) 행을 x, 열을 y로 표현
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 2) 행을 r, 열을 c로 표현
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

# 상(x-1, y)
nx = x + dx[0]
ny = y + dy[0]

# 하(x+1, y)
nx = x + dx[1]
ny = y + dy[1]

# 상(x-1, y)
nx = x + dx[2]
ny = y + dy[2]

# 상(x-1, y)
nx = x + dx[3]
ny = y + dy[3]

# for문으로 상하좌우 이동
for i in range(4):
nx = x + dx[i]
ny = y + dy[i]
```

### 1. 상하좌우로 이동 후 범위를 벗어나지 않는지 확인 및 갱신하기
```python
# 3X3 grid에서 x, y = (0,0)일 때

# 1. 델타값을 이용해 상하좌우 이동
for i in range(4):
nx = x + dx[i]
ny = y + dy[i]

    # 2. 범위를 벗어나지 않으면 갱신
    if 0 <= nx < 3 and 0 <= ny < 3:
        x = nx
        y = ny
```

### 2. 이차원 리스트의 상하좌우 탐색 정리
```python
# 3X3 grid에서 x, y = (0,0)일 때

# 1. 델타값 정의(상하좌우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 2. 이차원 리스트 순회
for x in range(n):
    for y in range(m):

        # 3. 델타값을 이용해 상하좌우 이동
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            # 4. 범위를 벗어나지 않으면 갱신
            if 0 <= nx < n and 0 <= ny < m:
                x = nx
                y = ny
```

### 3. 상하좌우 + 대각선의 8방향 델타값
```python
# 상, 하, 좌, 우, 좌상, 좌하, 우상, 우하

dx = [-1, 1, 0, 0, -1, 1, -1, 1]
dy = [0, 0, -1, 1, -1, -1, 1, 1]
```